//LINKS IMPORTANTES

rthree js orbitcontrols follow target

ARREGLAR PARPADEO AL IR ATRAS

ARREGLAR QUE COLISIONA CON DOS BLOQUES LIBRES

SI DA TIEMPO QUE FUESE MAS FLUIDO EL MOVIMIENTO

ARREGLAR QUE CUANDO SE SALTAN DOS BLOQUES, SE PEGA EL PERSONAJE AL MISMO

SI SE MUEVE EN EL PRIMER BLOQUE HACIA LA L INVERTIDA (SIN SALTAR) SE METE DENTRO DEL CUBO

//PRIORIDAD MAXIMA
DONE- Arreglar para que los chunks se reserven dinamicamente y no como lo estamos haciendo, que es siempre el mismo valor
DONE- Hacer un selector de tipo de material (ahora mismo se pone el mismo que el que se hace picking). Elegir bloque para poner [HIERBA] [TIERRA] [PIEDRA] [ROCA] [MADERAROBLE] [HIERBAROBLE] [CRISTAL] [PIEDRABASE] [GLOWSTONE] -> LOS DOS


//MUCHA IMPORTANCIA
- Más modelos jerárquicos (con sus movimientos) -> SERGIO
DONE - Varios bloques en la generación
DONE - Ver bloque seleccionado
- Revisar animacion Steve porque a veces no se reinicia -> ANDRES
- Hacer animaciones y fisicas independientes del ordenador -> ANDRES
DONE - Arreglar controles raton



/*Hoy*/
- Arreglar colisiones y físicas (mas o menos, lo mas importante) <-----


//MEDIA IMPORTANCIA
- Árboles y estructura (solo si se puede hacer varios bloques en la generación)
- Mejoras de iluminación
- Hacer que el cursor se capture y no haga falta pulsar los botones
DONE - Correr
- Niebla estilo Silent Hill
- Arreglar que al poner los bloques muy rapidos mientras se salta, a veces se mete dentro del suelo

//POCA IMPORTANCIA
- Ciclo día noche
- Animación al poner y quitar bloques
- Pantalla de inicio?

//POQUISIMA IMPORTANCIA
- Cámara en primera persona


















/*
    for(let i=0; i<this.bloques.length; i++){
      let aux=new THREE.BoxGeometry(1, 1, 1);
      aux.translate(this.bloques[i].x, this.bloques[i].y, this.bloques[i].z) 

      this.add(new THREE.Mesh(aux))
    }
/*
    let h = new cubos.Hierba();

    this.bloques=[];
    let matrix = new THREE.Matrix4();
    let k = 0;
    let amplitud = 100;
    for (let i = -31; i <= 32; i++) {
      for (let j = -31; j <= 32; j++) {
        let mesh = new THREE.Mesh(h.geometria, h.material);
        //let v = Math.round(noise.perlin2(i,j)*amplitud/5)*5;
        mesh.position.set(j * 16 / PM.PIXELES_ESTANDAR, -8 / PM.PIXELES_ESTANDAR, i * 16 / PM.PIXELES_ESTANDAR);
        this.bloques.push(mesh);
        this.add(mesh);
      }
    }
    //this.add(mesh);

/*    let t = new cubos.Tierra();

    //let meshtierra = new THREE.InstancedMesh(t.geometria, t.material, 32 * 32 * 2);
    this.meshtierra = new THREE.InstancedMesh(t.geometria, t.material, 32 * 32 * 2);
    let f = 0;
    for (let k = 1; k < 3; k++) {
      for (let i = -15; i <= 16; i++) {
        for (let j = -15; j <= 16; j++) {
          matrix.setPosition(j * 16 / PM.PIXELES_ESTANDAR, -8 / PM.PIXELES_ESTANDAR - k * 16 / PM.PIXELES_ESTANDAR, i * 16 / PM.PIXELES_ESTANDAR);
          this.meshtierra.setMatrixAt(f, matrix);
          f++;
        }
      }
    }
    this.add(this.meshtierra);

    let p = new cubos.Piedra();

    let meshpiedra = new THREE.InstancedMesh(p.geometria, p.material, 32 * 32 * 17);
    f = 0;
    for (let k = 3; k < 20; k++) {
      for (let i = -15; i <= 16; i++) {
        for (let j = -15; j <= 16; j++) {
          matrix.setPosition(j * 16 / PM.PIXELES_ESTANDAR, -8 / PM.PIXELES_ESTANDAR - k * 16 / PM.PIXELES_ESTANDAR, i * 16 / PM.PIXELES_ESTANDAR);
          meshpiedra.setMatrixAt(f, matrix);
          f++;
        }
      }

    }
    this.add(meshpiedra);

    let b = new cubos.PiedraBase();
    let meshbedrock = new THREE.InstancedMesh(b.geometria, b.material, 32*32);
    f=0;
    for (let i = -15; i <= 16; i++) {
      for (let j = -15; j <= 16; j++) {
        matrix.setPosition(j * 16 / PM.PIXELES_ESTANDAR, -8 / PM.PIXELES_ESTANDAR - 20 * 16 /PM.PIXELES_ESTANDAR, i * 16 / PM.PIXELES_ESTANDAR);
        meshbedrock.setMatrixAt(f, matrix);
        f++;
      }
          this.add(meshbedrock);

    } 

    
*/

    /*let h = new cubos.Hierba();
    //let mesh = new THREE.Mesh(h.geometria, h.material);
    let arMesh=[]

    for(let k = 0; k > -30; k--){
      for(let f = 8; f > -7; f--){
        for(let c = 8; c > -7; c--){
          //let mesh = new THREE.Mesh(h.geometria, h.material);
          let aux=h.geometria.clone();
          //aux.position.set(f, k, c);
          aux.translate(f, k, c);

          arMesh.push(aux);
          //this.add(aux);
        }
      }
    }
    console.log(arMesh.length);

    this.final=new THREE.Mesh(BufferGeometryUtils.mergeBufferGeometries(arMesh), h.material);

    this.add(this.final);
*/